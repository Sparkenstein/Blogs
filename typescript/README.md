# TypeScript [Part-1]

Few days ago I wrote a blog on JavaScript types. althought It was meant to be a beginner friendly introduction, we saw some Funny `conversions` of types happening in front of us. This bad boy is known as 'Coercion'. This happens usually when we try to compare or concat or modify one type with other forcibly. 

```js{2}
let variable = "0";
if(variable == false){
    console.log("variable is now coerced to a boolean while checking")
} else {
    console.log("variable is not coerced to a boolean")
}
```

This is not just a bad practice to compare two different types explicitly in js but also it can be very degnerous from the products perspective. 
try the same example with `===` instead (and changing the variable name ofc, otherwise it will result in error). 

Yeah, this is the reason why some people curse JavaScript. But infact they just don't understand what is going wrong.  To overcome this Microsoft released a new language around 5 years ago called `TypeScript`. TypeScript is nothing but a "strict syntactical superset of JavaScript[^1]". If you change your existing independent JavaScript file name to a `.ts` extentiona and run it through the TypeScript compiler (Transpiler actually, but Eh!) The code should run fine as it is. Because, TypeScript actully compiles to (Transpiles to, Yes. ) JavaScript only. let's take an example. But before that, you are going to need the TypeScript compiler (Transpiler) first.  Install it using:
```bash
npm i -g typescript
```
depending upon the OS, you may require to give the superuser rights before installing. And it will install everything that is needed to your computer.

Now let's try it hands on. Type the following in a file called `JSDemo.js`:
```js
let country = "Nigeria";
let groupD = ["Croatia", "Argentina", "Nigeria", "Iceland", 5]; // What the hell is this '5' doing here?

for (let i of groupD){
    if (i === country){
        console.info("The", country, "is in Group D");
    }
}
```
Now if you run the file with `node JSDemo.js`, it should print the output from `console.info();`. Now just copy the file in the same directory, rename it to `TSDemo.ts` (don't forget to change the extention as well.) and instead of typing `node TSDemo.ts` type `tsc TSDemo.ts`. `tsc` stands for TypeScript Compiler I guess (Don't know why!). It will parse your `.ts` file and create another file with the same name but with `.js` extention. And now you can run this newly generated file from node. and again, as nothing is changed in the code, it should give the same output. 

But that's not the only thing typescript is capable of. Of course, why would we use something that just changes files extension? Now open the js file generated by TypeScript compiler (Transpiler, I know, I know.), you'll see this file not exactly same as the one we have written, the variable names are different, the access type of variable is now `var` instead of `let`, Hell even the `for .. of ..` is changed as well. This is to ensure the backward compatibility with other browsers as well as the JavaScript engines that doesn't support all latest ES6 features. 

Let's dive more deep into TypeScript. The reason why it is named `TypeScript` is obvious. It deals with the `types`. TypeScript enables us to have static types even in JavaScript. Static types has many advantages over the Dynamic types. But we are not going to look into them right now. For now, just keep in mind that with TypeScript you can basically 'create' your own types as well. Let's modify the previous example to be 'Type Safe':

```typescript{2}
let country : string = "Nigeria";
let groupD : string[] = ["Croatia", "Argentina", "Nigeria", "Iceland", 5];

for (let i of groupD){
    if (i === country){
        console.info("The", country, "is in Group D");
    }
}
```

And run it through `tsc` again. BOOM!! You will get an error. Something like `TS2322: blah blah this and that`. Why did this happen? Look carefully, while we were declaring the variables, in the later example, we actually defined the 'type' annotation for the TypeScript to identify the type where the respective variable belongs. While parsing this file, the transpiler will detect the types of variables and prohibit any other types getting assigned to it. That's why in the second line, we get an error because we defined `groupD` to be an array of strings only but in last position we actually added an integer. 

Let' see some more examples with more basic ypes:
```ts
let groupHisAwesome: boolean = true; // Boolean
let peruPoints: number = 3; // Number, even octals, binary and hex are also supported OOTB
let japanFlagColor: string = "white-red"; // a string of course
let groupE: Array<string> = ["Brazil", "Switzerland", "Serbia", "Costa Rica"] // Another way to define an array
```

and from the new types for js:

```ts
enum Teams {France, Denmark, Peru, Australia} // Enums from famous OO languages
let denmark: Team = Teams.Denmark;

let points: [string, number] = ["First Rount", 3]; // A tuple. Nothing but a fixed array of predefined types
```
and if you are not sure what type it can hold, or If you just want to allow it to hold any type, you can assign it to `any` type 
```ts
var manager: any = "Alex";
manager = 40;
```

The power of the TypeScript is not only limited to variables, but you can define types for functions and classes as well. When you think about it, functions are just low-key objects again. so why not?
```ts
let getTeamName = function teamName(): string {
    return "SomeTeamName"; // It HAS to be a string though.
}
console.info(getTeamName());
```

You can also use `void` type if your function does not return anything
```ts
function goal() : void {
    console.log("Goooooaall");
}
```

Well, that's it for the first part. stay tuned to the advance TypeScript which I am going to cover in my [next post](./part2/).


[^1]: [Wiki](https://en.wikipedia.org/wiki/TypeScript)